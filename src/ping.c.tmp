/*
 * Copyright (c) 2025, lomaster. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include "../include/base.h"

static dlt_t *dlt = NULL;      /* socket */
static long long interval = 0; /* delay/interval */
static bool sflag = 0;
static bool vflag = 0;
static struct in_addr sopt = { 0 };
static bool Sflag = 0;
static struct ether_addr Sopt = { 0 };
static bool Iflag = 0;
static char *Iopt = NULL;
static bool prstats = 0; /* print last stats? */
static size_t ntransmitted = 0;
static size_t nreceived = 0;
static size_t nrepeats = 0;
static size_t ntry = 3;
static long long tmin = 0;
static long long wait = 150 * 1000000LL; /* timeout */
static long long tmax = 0;
static if_data_t ifd = { 0 }; /* interface data */
static long long tsum = 0;
static int method = IPPROTO_UDP;
static long long *rtts = NULL;
static bool reached = 0;
static int curhop = 0;
static u_short lid = 0; /* last ip id */
static bool Aflag = 0;
static bool Pflag = 0;
static bool pflag = 0;
static size_t unreachable = 0;
static int Popt = 0;
static int dstport = 32768 + 666;
static bool _6flag = 0;
static struct in6_addr _6opt = { 0 };
static int first = 1;
static int total = 30;
static int ttl = 0;
static int mttl = 0;
static ipaddr_t source = { 0 };
static int off = 0;
static ipaddr_t curtp = { 0 }; /* current target */
static bool oflag = 0;
static int oopt = 0;
static size_t hopid = 0;
static u_char *payload;
static size_t payloadlen;

/*
 *		U S A G E
 *
 * Takes a vector of arguments (argv) and prints help
 * about the TRACEROUTE options; also, terminates the
 * program.
 */
inline static void
usage(char **av)
{
	/*
	 * all
	 * tcp ack
	 * tcp syn
	 * icmp echo
	 * icmp info
	 * icmp tstamp
	 * udp
	 * sctp cookie
	 * udp lite ?
	 */
	fputs("  -A \n", stderr);
	fputs("  -K \n", stderr);
	fputs("  -Y \n", stderr);
	fputs("  -E \n", stderr);
	fputs("  -N \n", stderr);
	fputs("  -M \n", stderr);
	fputs("  -U \n", stderr);
	fputs("  -C \n", stderr);
	fputs("  -L \n", stderr);

	fputs("Usage\n", stderr);
	fprintf(stderr, "  %s [options] <targets>\n\n", av[0]);
	fputs("  -I <dev>   set your interface and his info\n", stderr);
	fputs("  -s <ipv4>  set source ipv4 address\n", stderr);
	fputs("  -6 <ipv6>  set source custom ipv6 address\n", stderr);
	fputs("  -z <tos>   set num in Type Of Service/Traffic class\n",
	    stderr);
	fputs("  -S <mac>   set source mac address\n", stderr);
	fputs("  -i <time>  set interval between packets; ex: 300ms\n", stderr);
	fputs("  -w <time>  set wait time or timeout; ex: 2s, 10ms\n", stderr);
	fputs("  -H <hex>   set payload data in hex numbers\n", stderr);
	fputs("  -p <port>  set destination port\n", stderr);
	fputs("  -a <ascii> set payload data in ascii\n", stderr);
	fputs("  -l <len>   set random payload data\n", stderr);
	fputs("  -P <port>  set source (your) port\n", stderr);
	fputs("  -n <count> set your num of try\n", stderr);
	fputs("  -T <ttl>   set ttl\n", stderr);
	fputc('\n', stderr);
	fputs("  -4  set More Fragment flag (ipv4)\n", stderr);
	fputs("  -r  set Reserved Fragment flag (ipv4)\n", stderr);
	fputs("  -d  set Dont't Fragment flag (ipv4)\n", stderr);
	fputs("  -f  flood ping\n", stderr);
	fputs("  -a  k\n", stderr);
	fputs("  -o  exit after first reply packet\n", stderr);
	fputs("  -q  enable quiet output\n", stderr);
	fputs("  -n  no resolve dns\n", stderr);
	fputs("  -v  show some debugging information\n", stderr);
	fputs("  -h  show this help message and exit\n", stderr);

	fputs("\nExamples\n", stderr);
	exit(0);
}

/*
 *		C A L L B A C K
 *
 * Essentially, this is a packet filter that is passed
 * to the receiving function so it can receive the
 * desired packet.  If the packet is ours, it returns 1,
 * or 0.
 */
inline static bool
callback(void *in, size_t n, void *arg)
{
	ipaddr_t *target = (ipaddr_t *)arg;
	u_char *buf = (u_char *)in;

	source.af = target->af;

	switch (target->af) {
	case AF_INET:
		if (n < 42)
			return 0;
		if (ntohs(*(u_short *)(buf + 12)) != 0x0800)
			return 0;
		if (buf[23] != IPPROTO_ICMP) /* only icmp packets */
			return 0;

		/* We can conclude whether the host has been reached
		 * on the current TTL from the fact that we received
		 * a DEST UNREACHED message indicating that the
		 * protocol or port is unavailable.  */
		if (buf[34] == 3) {
			if (memcmp((buf + 54), ifd.srcip4, 4) != 0)
				return 0;
			if (memcmp((buf + 58), &target->ip.v4, 4) != 0)
				return 0;
			if (buf[35] != 3 && buf[35] != 2) {
				++unreachable;
				return 0;
			}

			if (ntohs((*(u_short *)(buf + 42 + 4))) != lid)
				return 0;

			memcpy(&source.ip.v4, (buf + 58), 4);
			reached = 1; /* AEEEE */
			break;
		}
		/* Or coming from ICMP_ECHO_REPLY, but only when the
		 * ID and seq match.  */
		else if (buf[34] == 0) {
			if (ntohs((*(u_short *)(buf + 38))) != lid)
				return 0;
			if (ntohs((*(u_short *)(buf + 40))) != hopid)
				return 0;

			memcpy(&source.ip.v4, (buf + 26), 4);
			reached = 1; /* AEEEE */
			break;
		}
		if (buf[34] != /* Time Exceed */ 11 &&
		    buf[35] == /* Intrans */ 0)
			return 0;
		if (memcmp((buf + 30), ifd.srcip4, 4) != 0) /* ip dst */
			return 0;
		if (ntohs((*(u_short *)(buf + 42 + 4))) != lid)
			return 0;

		memcpy(&source.ip.v4, (buf + 26), 4);
		break;
	case AF_INET6:
		if (n < 54)
			return 0;
		if (ntohs(*(u_short *)(buf + 12)) != 0x86dd)
			return 0;
		if (buf[20] != IPPROTO_ICMPV6) /* only icmp6 packets */
			return 0;

		/* The same as with ipv4, but there is no protocol
		 * error.  */
		if (buf[54] == 1) {
			const u_int *inner_ipv6_hdr = (const u_int *)(buf + 62);
			if ((ntohl(inner_ipv6_hdr[0]) & 0x000FFFFF) != lid)
				return 0;
			if (buf[55] == 4) {
				memcpy(source.ip.v6.s6_addr, (buf + 69), 16);
				reached = 1; /* AEEEE */
				break;
			}
		} else if (buf[54] == 129) {
			if (ntohs((*(u_short *)(buf + 58))) != lid)
				return 0;
			if (ntohs((*(u_short *)(buf + 60))) != hopid)
				return 0;

			memcpy(source.ip.v6.s6_addr, (buf + 22), 16);
			reached = 1; /* AEEEE */
			break;
		}

		if (buf[54] != /* Time Exceed */ 3 &&
		    buf[55] == /* Intrans */ 0)
			return 0;
		if (memcmp((buf + 38), ifd.srcip6, 16) != 0) /* ip dst */
			return 0;

		const u_int *inner_ipv6_hdr = (const u_int *)(buf + 62);
		if ((ntohl(inner_ipv6_hdr[0]) & 0x000FFFFF) != lid)
			return 0;

		memcpy(source.ip.v6.s6_addr, (buf + 22), 16);
		break;
	}

	return 1;
}

/*
 *		S T A T S
 *
 * Takes the IP address of the target in <target>,
 * and prints the current TRACEROUTE statistics
 * according to the options.
 */
inline static void
stats(ipaddr_t *target)
{
	printf("\n----%s PING Statistics----\n", ipaddr_ntoa(target));
	printf("%ld packets transmitted, %ld packets received", ntransmitted,
	    nreceived);
	if (nrepeats)
		printf(", +%ld duplicates, ", nrepeats);
	if (ntransmitted) {
		if (nreceived > ntransmitted)
			printf(" -- somebody's printing up packets!\n");
		else
			printf(", %ld%% packet loss\n",
			    (size_t)(((ntransmitted - nreceived) * 100) /
				ntransmitted));
	}
	if (nreceived) {
		char tmp[1000];
		printf("round-trip (rtt) min/avg/max = %s",
		    timefmt(tmin, tmp, sizeof(tmp)));
		printf("/%s",
		    timefmt((long long)tsum / (long long)nreceived, tmp,
			sizeof(tmp)));
		printf("/%s", timefmt(tmax, tmp, sizeof(tmp)));
		putchar('\n');
	}

	putchar('\n');
	prstats = 1;
}

/*
 *		F I N I S H
 *
 * Should be called when the program terminates;
 * prints the last target's statistics if none
 * were printed, and closes the socket.
 */
inline static NORETURN void
finish(int sig)
{
	(void)sig;
	if (!prstats)
		stats(&curtp);
	if (payload)
		free(payload);
	if (rtts)
		free(rtts);
	if (dlt)
		dlt_close(dlt);
	exit(0);
}

/*
 *		R E S O L V E _ D N S
 *
 * Gets DNS based on its IP address, works with both
 * IPv4 and IPv6; returns a static buffer. It returns
 * the DNS by enclosing it in parentheses (). If it is
 * not found, it returns (???)
 */
static inline const char *
resolve_dns(ipaddr_t *target)
{
	struct sockaddr_in6 sin6 = { 0 };
	struct sockaddr_in sin = { 0 };
	static char res[4096 + 2];
	char host[4096] = { 0 };

	memset(res, 0, sizeof(res));
	switch (target->af) {
	case AF_INET:
		sin.sin_family = (u_short)target->af;
		sin.sin_addr = target->ip.v4;
		if (getnameinfo((struct sockaddr *)&sin, sizeof(sin), host,
			sizeof(host), NULL, 0, 0) == 0) {
			snprintf(res, sizeof(res), "(%s)", host);
			return res;
		}
		break;
	case AF_INET6:
		sin6.sin6_family = (u_short)target->af;
		sin6.sin6_addr = target->ip.v6;
		if (getnameinfo((struct sockaddr *)&sin6, sizeof(sin6), host,
			sizeof(host), NULL, 0, 0) == 0) {
			snprintf(res, sizeof(res), "(%s)", host);
			return res;
		}
		break;
	}

	return "(\?\?\?)";
}

/*
 *		T V R T T
 *
 * Calculates the corrected response time using
 * tvsub(), updates statistics, and returns the
 * response time.
 */
inline static long long
tvrtt(struct timeval *ts_s, struct timeval *ts_e)
{
	struct timeval tv = *ts_e;
	long long rtt;

	tvsub(&tv, ts_s);
	rtt = (long long)tv.tv_sec * 1000000000LL +
	    (long long)tv.tv_usec * 1000LL;

	tsum += rtt;
	tmax = (rtt > tmax) ? rtt : tmax;
	tmin = (rtt < tmin) ? rtt : tmin;

	return rtt;
}

/*
 *		S E N D P R O B E
 *
 * Creates a package in <outpack> according to
 * the options, sends it, and updates statistics.
 */
inline static void
sendprobe(ipaddr_t *target, int proto, u_char *data, u_int datalen)
{
	u_char outpack[2048] = { 0 };
	size_t len = 0, s;
	ssize_t n;

	len += 34;
	if (target->af == AF_INET6) {
		len += 20;

		/* fix proto */
		proto = (proto == IPPROTO_ICMP) ? IPPROTO_ICMPV6 : proto;
	}
	s = len; /* skip ad payload */
	switch (proto) {
	case IPPROTO_TCP:
		len += 20;
		break;
	case IPPROTO_SCTP:
		len += 16; /* sctp + cookie chunk */
		break;
	case IPPROTO_ICMP: /* icmp + echo msg (valid for ipv6) */
	case IPPROTO_ICMPV6:
	case IPPROTO_UDPLITE:
	case IPPROTO_UDP:
		len += 8;
		break;
	}
	len += datalen;

	lid = random_u16();

	memcpy(outpack, ifd.dst, 6);
	memcpy(outpack + 6, ifd.src, 6);
	*(u_short *)(outpack + 12) = htons(
	    (target->af == AF_INET) ? 0x0800 : 0x86dd);

	switch (target->af) {
	case AF_INET:
		outpack[14] = (4 << 4) | 5 /*5+(optslen/4)*/; /* version|ihl */
		outpack[15] = (oflag) ? oopt : 0;	      /* tos */
		*(u_short *)(outpack + 16) = htons(
		    (u_short)(len - 14));		 /* tot_len +optslen */
		*(u_short *)(outpack + 18) = htons(lid); /* id */
		*(u_short *)(outpack + 20) = htons((u_short)off); /* off */
		outpack[22] = (u_char)ttl;			  /* ttl */
		outpack[23] = (u_char)proto;			  /* proto */
		*(u_short *)(void *)(outpack + 24) = 0;		  /* chksum */
		for (n = 0; n < 4; n++)
			outpack[26 + n] = ifd.srcip4[n], /* via in caelum */
			    outpack[30 + n] = (ntohl(target->ip.v4.s_addr) >>
						  (24 - 8 * n)) &
			    0xff;
		*(u_short *)(outpack + 24) = in_cksum((u_short *)(outpack + 14),
		    20);
		break;
	case AF_INET6:
		outpack[14] = ((0x06 << 4) |
		    ((((oflag) ? oopt : 0) & 0xF0) >> 4)); /* version|tc */
		outpack[15] = (u_char)(((((oflag) ? oopt : 0) & 0x0F)
					   << 4) | /* flowlabel */
		    ((lid & 0xF0000) >> 16));
		outpack[16] = ((lid & 0x0FF00) >> 8),
		outpack[17] = ((lid & 0x000FF));
		*(u_short *)(outpack + 18) = htons(
		    (u_short)len - (54));    /* payload length */
		outpack[20] = (u_char)proto; /* nexthdr (protocol) */
		outpack[21] = (u_char)ttl;   /* hoplimit (ttl) */
		for (n = 0; n < 16; n++)     /* src+dst */
			outpack[22 + n] = ifd.srcip6[n],
				     outpack[22 + 16 + n] =
					 target->ip.v6.s6_addr[n];
		break;
	}

	switch (proto) {
	case IPPROTO_ICMP:
	case IPPROTO_ICMPV6:
		outpack[s] = (target->af == AF_INET6) ? 128 : 8; /* type */
		outpack[s + 1] = 0;				 /* code */
		*(u_short *)(outpack + s + 2) = htons(0);	 /* chksum */
		*(u_short *)(outpack + s + 4) = htons(lid);	 /* id */
		*(u_short *)(outpack + s + 6) = htons(hopid);	 /* seq */

		if (data && datalen)
			memcpy(outpack + s + 8, data, datalen);

		switch (target->af) {
		case AF_INET:
			*(u_short *)(outpack + s +
			    2) = in_cksum((u_short *)(outpack + s),
			    (int)(8 + datalen));
			break;
		case AF_INET6:
			*(u_short *)(outpack + s +
			    2) = in6_pseudocksum(ifd.srcip6,
			    (u_char *)&target->ip.v6, IPPROTO_ICMPV6,
			    (u_int)(8 + datalen), (outpack + s));
			break;
		}

		break;
	case IPPROTO_TCP:
		*(u_short *)(outpack + s) = (Pflag) ?
		    htons(Popt) :
		    htons(random_u16()); /* src port */
		*(u_short *)(outpack + s + 2) = (pflag) ?
		    htons(dstport) :
		    htons(dstport + hopid); /* dst port */
		memcpy(outpack + s + 4, &(u_int) { htonl(random_u32()) },
		    sizeof(u_int)); /* seq */
		memcpy(outpack + s + 8, &(u_int) { htonl(0) },
		    sizeof(u_int));			      /* ack */
		outpack[s + 12] = (5 << 4) | (0 & 0x0f);      /* off | res */
		outpack[s + 13] = 2;			      /* flags */
		*(u_short *)(outpack + s + 14) = htons(1024); /* window */
		*(u_short *)(outpack + s + 16) = 0;	      /* chksum */
		*(u_short *)(outpack + s + 18) = 0;	      /* urp */

		if (data && datalen)
			memcpy(outpack + s + 20, data, datalen);

		switch (target->af) {
		case AF_INET:
			*(u_short *)(outpack + s +
			    16) = in_pseudocksum(ifd.srcip4,
			    (u_char *)&target->ip.v4, (u_char)proto,
			    (20 + (u_short)datalen), (outpack + s));
			break;
		case AF_INET6:
			*(u_short *)(outpack + s +
			    16) = in6_pseudocksum(ifd.srcip6,
			    (u_char *)&target->ip.v6, (u_char)proto,
			    (u_int)(20 + datalen), (outpack + s));
			break;
		}

		break;
	case IPPROTO_SCTP:
		*(u_short *)(outpack + s) = (Pflag) ?
		    htons(Popt) :
		    htons(random_u16()); /* src port */
		*(u_short *)(outpack + s + 2) = (pflag) ?
		    htons(dstport) :
		    htons(dstport + hopid); /* dst port */
		*(u_int *)(outpack + s + 4) = htonl(random_u32()); /* vtag */
		*(u_int *)(outpack + s + 8) = htonl(0);		   /* chksum */
		outpack[s + 12] = 0x0a;				   /* type */
		outpack[s + 13] = 0;				   /* flags */
		*(u_short *)(outpack + s + 14) = htons(
		    4 + (u_short)datalen); /* len */

		if (data && datalen)
			memcpy(outpack + s + 16, data, datalen);

		*(u_int *)(outpack + s + 8) = htonl(
		    adler32(1, (outpack + s) /* final chksum */
			,
			16 + datalen));
		break;
	case IPPROTO_UDP:
		*(u_short *)(outpack + s) = (Pflag) ?
		    htons(Popt) :
		    htons(random_u16()); /* src port */
		*(u_short *)(outpack + s + 2) = (pflag) ?
		    htons(dstport) :
		    htons(dstport + hopid); /* dst port */
		*(u_short *)(outpack + s + 4) = htons(
		    8 + (u_short)datalen);		  /* len */
		*(u_short *)(outpack + s + 6) = htons(0); /* chksum */

		if (data && datalen)
			memcpy(outpack + s + 8, data, datalen);

		switch (target->af) {
		case AF_INET:
			*(u_short *)(outpack + s +
			    6) = in_pseudocksum(ifd.srcip4,
			    (u_char *)&target->ip.v4, (u_char)proto,
			    (8 + (u_short)datalen), (outpack + s));
			break;
		case AF_INET6:
			*(u_short *)(outpack + s +
			    6) = in6_pseudocksum(ifd.srcip6,
			    (u_char *)&target->ip.v6, (u_char)proto,
			    (u_int)(8 + datalen), (outpack + s));
			break;
		}

		break;
	case IPPROTO_UDPLITE:
		*(u_short *)(outpack + s) = (Pflag) ?
		    htons(Popt) :
		    htons(random_u16()); /* src port */
		*(u_short *)(outpack + s + 2) = (pflag) ?
		    htons(dstport) :
		    htons(dstport + hopid);		  /* dst port */
		*(u_short *)(outpack + s + 4) = htons(0); /* checkcrg */
		*(u_short *)(outpack + s + 6) = htons(0); /* chksum */

		if (data && datalen)
			memcpy(outpack + s + 8, data, datalen);

		switch (target->af) {
		case AF_INET:
			*(u_short *)(outpack + s +
			    6) = in_pseudocksum(ifd.srcip4,
			    (u_char *)&target->ip.v4, (u_char)proto,
			    (8 + (u_short)datalen), (outpack + s));
			break;
		case AF_INET6:
			*(u_short *)(outpack + s +
			    6) = in6_pseudocksum(ifd.srcip6,
			    (u_char *)&target->ip.v6, (u_char)proto,
			    (u_int)(8 + datalen), (outpack + s));
			break;
		}

		break;
	}

	n = dlt_send(dlt, outpack, len);
	if (n < 0 || n != len) {
		if (n < 0)
			warn("sendto");

		warnx("wrote %s %lu chars, ret=%zd", ipaddr_ntoa(target), len,
		    n);
	}

	++ntransmitted;
}

/*
 *		L O O P
 *
 * The main function of the code; receives the
 * target's IP address and tracerouting it; before
 * doing this, of course, it resets the
 * statistics.
 */
inline static void
loop(ipaddr_t *ip)
{
	ntransmitted = 0;
	tsum = 0;
	nrepeats = 0;
	tmax = LLONG_MIN;
	nreceived = 0;
	prstats = 0;
	tmin = LLONG_MAX;
	curtp = ip;

	printf("PING %s (%s): %zu data bytes\n",
	    resolve_dns(ip), ipaddr_ntoa(ip), payloadlen);

	for (;;) {
		struct timeval ts_s, ts_e;
		u_char buf[2048] = { 0 };
		ssize_t n;

		pinger(ip);
		if ((n = dlt_recv_cb(dlt, buf, sizeof(buf), callback,
			 (void *)ip, wait, &ts_s, &ts_e)) == -1) {
			warnx("no response received");
			if (errno != 0)
				warn("recv");

		} else {
			nreceived++; /* Packet received.  */
			pr_pack(buf, n, tvrtt(&ts_s, &ts_e), ntransmitted);
		}

		if (/* nreceived? -N flag ? */ntransmitted == npackets)
			break;

		sleepns(interval);
	}

	stats(ip);
}

/*
 *		I F _ S E T U P
 *
 * Gets the network interface and its associated
 * data, also modifies them according to the
 * options, and opens the socket.
 */
inline static void
if_setup(void)
{
	if (!Iflag) {
		if (!if_get(NULL, &ifd))
			errx(1, "no suitable devices found");
	} else {
		if (!if_get(Iopt, &ifd))
			errx(1, "device \"%s\" not found", Iopt);
		if (!__is_network_sendable(&ifd))
			errx(1, "device \"%s\" doesn't fit", Iopt);
	}
	if (sflag)
		memcpy(ifd.srcip4, &sopt, 4);
	if (Sflag)
		memcpy(ifd.src, &Sopt, 6);
	if (_6flag)
		memcpy(ifd.srcip6, _6opt.s6_addr, 16);
	if (vflag)
		if_output(stderr, &ifd);
	if (payloadlen > (size_t)ifd.mtu)
		errx(1,
		    "your mtu is (%d), your length"
		    " data is \"%zu\"",
		    ifd.mtu, payloadlen);

	if (!(dlt = dlt_open(ifd.name)))
		errx(1, "failed open socket");
}

/*
 *		P I N G
 */
int
main(int c, char **av)
{
	ipaddr_t ip;
	int ch;

	if (c <= 1)
		usage(av);

	signal(SIGINT, finish);
	while ((ch = getopt(c, av,
		    "I:s:6:o:S:i:P:p:w:m:f:n:H:a:l:v4rdAEYULCh")) != -1) {
		switch (ch) {
		case 'I':
			Iflag = 1;
			Iopt = optarg;
			break;
		case '4':
			off |= 0x8000;
			break;
		case 'A':
			Aflag = 1;
			break;
		case 'E':
			method = IPPROTO_ICMP;
			break;
		case 'Y':
			method = IPPROTO_TCP;
			break;
		case 'U':
			method = IPPROTO_UDP;
			break;
		case 'L':
			method = IPPROTO_UDPLITE;
			break;
		case 'C':
			method = IPPROTO_SCTP;
			break;
		case '6':
			if (inet_pton(AF_INET6, optarg, &_6opt) != 1)
				errx(1, "failed convert \"%s\" in ipv6",
				    optarg);
			_6flag = 1;
			break;
		case 'r':
			off |= 0x8000;
			break;
		case 'm':
			if (!u_numarg(optarg, 0, UCHAR_MAX, &total,
				sizeof(total)))
				errx(1, "invalid ttl \"%s\"", optarg);
			break;
		case 'f':
			if (!u_numarg(optarg, 0, UCHAR_MAX, &first,
				sizeof(first)))
				errx(1, "invalid ttl \"%s\"", optarg);
			break;
		case 'd':
			off |= 0x4000;
			break;
		case 'o':
			if (!u_numarg(optarg, 0, UCHAR_MAX, &oopt,
				sizeof(oopt)))
				errx(1, "invalid tos \"%s\"", optarg);
			oflag = 1;
			break;
		case 'v':
			vflag = 1;
			break;
		case 'p':
			if (!u_numarg(optarg, 0, USHRT_MAX, &dstport,
				sizeof(dstport)))
				errx(1, "invalid port \"%s\"", optarg);
			pflag = 1;
			break;
		case 'P':
			if (!u_numarg(optarg, 0, USHRT_MAX, &Popt,
				sizeof(Popt)))
				errx(1, "invalid port \"%s\"", optarg);
			Pflag = 1;
			break;
		case 'n':
			if (!u_numarg(optarg, 0, SIZE_MAX, &ntry, sizeof(ntry)))
				errx(1, "invalid number \"%s\"", optarg);
			break;
		case 'H': {
			u_char *hextmp = NULL;
			if (!(hextmp = hex_ahtoh(optarg, &payloadlen)))
				errx(1, "invalid hex string specification");
			if (!(payload = memcpy(calloc(1, payloadlen), hextmp,
				  payloadlen)))
				errx(1, "memory allocation failed");
			break;
		}
		case 'a':
			if (!(payload = (u_char *)strdup(optarg)))
				errx(1, "failed allocated");
			payloadlen = strlen((char *)payload);
			break;
		case 'l':
			if (!u_numarg(optarg, 0, UINT_MAX, &payloadlen,
				sizeof(payloadlen)))
				errx(1, "invalid data len \"%s\"", optarg);
			if (!(payload = (u_char *)randomstr(payloadlen,
				  DEFAULT_DICTIONARY)))
				errx(1, "failed generate random data");
			break;
		case 'w':
			if ((wait = strtons(optarg)) == -1)
				errx(1, "failed convert \"%s\" in time",
				    optarg);
			break;
		case 'i':
			if ((interval = strtons(optarg)) == -1)
				errx(1, "failed convert \"%s\" in time",
				    optarg);
			break;
		case 's':
			if (inet_pton(AF_INET, optarg, &sopt) != 1)
				errx(1, "failed convert \"%s\" in ipv4",
				    optarg);
			sflag = 1;
			break;
		case 'S':
			if (!(ether_aton_r(optarg, &Sopt)))
				errx(1, "failed convert \"%s\" in mac", optarg);
			Sflag = 1;
			break;
		case '?':
		default:
			usage(av);
		}
	}

	c -= optind;
	av += optind;
	if_setup();
	random_init(dev_urandom, NULL);

	if (c <= 0)
		errx(1, "no targets specified");

	if (!(rtts = calloc(ntry, sizeof(long long))))
		errx(1, "failed allocated time");

	while (*av) {
		char *p = *av++, *sb;

		if ((sb = strchr(p, '/')))
			*sb++ = '\0';
		if (!ipaddr_pton(p, &ip)) {
			if (!resolveipv4(p, &ip.ip.v4))
				errx(1, "failed resolve \"%s\"", p);
			else
				ip.af = AF_INET;
		}

		if (ip.af == AF_INET && !ifd.support4)
			errx(1, "device does not support ipv4");
		if (ip.af == AF_INET6 && !ifd.support6)
			errx(1, "device does not support ipv6");

		if (!sb)
			loop(&ip);
		else {
			u_char mask[16] = { 0 };
			u_char net[16] = { 0 };
			__uint128_t ip6 = 0;
			__uint128_t n;
			u_short bits;
			int i;

			if (!u_numarg(sb, 0, (ip.af == AF_INET) ? 32 : 128,
				&bits, sizeof(bits)))
				errx(1, "invalid bits \"%s\"", sb);

			ip_btom(ip.af, bits, mask);
			ip_net(((ip.af == AF_INET) ? (u_char *)&ip.ip.v4 :
						     (u_char *)&ip.ip.v6),
			    mask, net);
			switch (ip.af) {
			case AF_INET:
				n = (bits == 32) ?
				    1 :
				    (__uint128_t)1 << (32 - bits);
				ip.ip.v4.s_addr = htonl((net[0] << 24) |
				    (net[1] << 16) | (net[2] << 8) | net[3]);
				break;
			case AF_INET6:
				if (bits >= 128)
					n = 1;
				else if (bits == 0)
					n = ~(__uint128_t)0;
				else
					n = (__uint128_t)1 << (128 - bits);
				for (i = 0; i < 16; i++) {
					ip6 <<= 8;
					ip6 |= net[i];
				}
				break;
			}

			if (vflag) {
				fprintf(stderr, "Target cidr: %s/%s (", p, sb);
				p128(n);
				fflush(stdout);
				fprintf(stderr, " ips)\n");
			}

			while (n--) {
				for (i = 15; ip.af == AF_INET6 && i >= 0; i--)
					ip.ip.v6.s6_addr[i] =
					    (u_char)((ip6 >> (8 * (15 - i))) &
						0xFF);

				loop(&ip);

				/* Next address.  */
				switch (ip.af) {
				case AF_INET6:
					++ip6;
					break;
				case AF_INET:
					ip.ip.v4.s_addr = ntohl(
					    ip.ip.v4.s_addr);
					ip.ip.v4.s_addr = htonl(
					    ++ip.ip.v4.s_addr);
					break;
				}
			}
		}
	}

	finish(0);
}
